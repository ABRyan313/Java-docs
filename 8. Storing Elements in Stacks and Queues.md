# Storing Elements in Stacks and Queues

### **Key Points: Queue Hierarchy in Java**  

- **Queue** was introduced in **Java SE 5** as part of the **Collections Framework**.  
- In **Java SE 6**, it was further extended by the **Deque (Double-Ended Queue) interface**.  
- **Queue** extends the **Collection interface** and follows the **FIFO (First In, First Out) rule**.  
- **Deque** allows adding and removing elements from both ends.  

📌 **Queue Interface Hierarchy (Simplified):**  
```
Collection
   ├── Queue (FIFO)
   │      ├── LinkedList
   │      ├── PriorityQueue
   │
   ├── Deque (Double-ended Queue)
          ├── ArrayDeque
          ├── LinkedList
```

- **Queue Implementations:**
  - `LinkedList` → Can act as a **Queue** or a **List**.  
  - `PriorityQueue` → Orders elements based on priority, **not insertion order**.  

- **Deque Implementations:**
  - `ArrayDeque` → More efficient than `Stack` and `LinkedList`.  
  - `LinkedList` → Implements `Deque`, so supports both queue and list operations.  

✅ **Use `Queue`** when tasks need to be processed in order.  
✅ **Use `PriorityQueue`** when elements should be removed based on priority.  
✅ **Use `Deque`** when you need **flexible insertion/removal from both ends**.


# Pushing, Popping and Peeking (Stack & Queue)


- **Stack (LIFO - Last In, First Out)** → Last added element is removed first.  
- **Queue (FIFO - First In, First Out)** → First added element is removed first.  

📌 **Main Operations:**  

#### **1️⃣ Stack Example (Using `Stack` Class)**  
```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        stack.push(10); // Push
        stack.push(20);
        System.out.println(stack.peek()); // Peek: 20
        System.out.println(stack.pop()); // Pop: 20
        System.out.println(stack); // Remaining Stack: [10]
    }
}
```

#### **2️⃣ Queue Example (Using `LinkedList` as Queue)**  
```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(10); // Push
        queue.add(20);
        System.out.println(queue.peek()); // Peek: 10
        System.out.println(queue.poll()); // Poll: 10
        System.out.println(queue); // Remaining Queue: [20]
    }
}
```

🔹 **Why are they important?**  
1. **Simple** → Easy to implement, even in early computing.  
2. **Useful** → Many algorithms rely on stacks (e.g., recursion, expression evaluation).

# Modeling Queues and Stacks

