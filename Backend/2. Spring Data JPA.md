# Spring Data JPA Questions


**Q: What's the difference between JPA, Hibernate, and Spring Data JPA?**  
**A:** JPA is the specification, Hibernate is the implementation, Spring Data JPA is the abstraction layer that simplifies JPA usage with repository patterns and query methods.

---

**Q: When to use @Query vs derived query methods?**  
**A:** Derived methods for simple queries (`findByName`), `@Query` for complex queries, joins, or custom SQL. Native queries with `nativeQuery=true` for database-specific operations.

---

**Q: What's the difference between @OneToMany and @ManyToOne mappings?**  
**A:** `@OneToMany` maps one entity to multiple (Parent → Children), `@ManyToOne` maps multiple to one (Children → Parent). Use bidirectional with `mappedBy` to avoid extra join tables.

---

**Q: How does lazy vs eager loading work?**  
**A:** **LAZY** loads data on-demand (default for collections), **EAGER** loads immediately. LAZY prevents N+1 queries but can cause `LazyInitializationException` outside transaction scope.

---

**Q: What's @Transactional and when is it needed?**  
**A:** Ensures database operations are atomic. Required for write operations, multiple queries, and lazy loading. Use `readOnly=true` for read operations to optimize performance.

---

**Q: How do you handle the N+1 query problem?**  
**A:** Use `@EntityGraph`, `JOIN FETCH` in JPQL, or batch fetching. `@EntityGraph` is cleanest — defines which associations to fetch in a single query.

---

**Q: What's the difference between save() and saveAndFlush()?**  
**A:** `save()` persists to persistence context, `saveAndFlush()` immediately writes to database. Use `saveAndFlush()` when you need the generated ID immediately or for batch operations.

---

**Q: How do you implement custom repository methods?**  
**A:** Create custom interface, implement it with `@Repository`, and extend in your main repository interface. Access `EntityManager` for complex queries via `@PersistenceContext`.

---

**Q: What's @Version used for?**  
**A:** Optimistic locking — prevents concurrent updates by checking version field. Hibernate automatically increments version on updates, throws exception on version mismatch.

---

**Q: How do you handle database migrations with Spring Boot?**  
**A:** Use **Flyway** or **Liquibase** for version-controlled migrations. Flyway uses SQL scripts (`V1__Create_tables.sql`), Liquibase uses XML/YAML. Both integrate seamlessly with Spring Boot.

---
